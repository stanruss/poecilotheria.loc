<?php return array (
  'unique_key' => 'category',
  'preserve_keys' => false,
  'update_object' => true,
  'related_objects' => 
  array (
    'Snippets' => 
    array (
      'f2f57e82850f5923dc6ac4bf5ed85c8c' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"TaggerGetTags","description":"","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * TaggerGetTags\\n *\\n * DESCRIPTION\\n *\\n * This Snippet allows you to list tags for resource(s), group(s) and all tags\\n *\\n * PROPERTIES:\\n *\\n * &resources       string  optional    Comma separated list of resources for which will be listed Tags\\n * &parents         string  optional    Comma separated list of parents for which will be listed Tags\\n * &groups          string  optional    Comma separated list of Tagger Groups for which will be listed Tags\\n * &rowTpl          string  optional    Name of a chunk that will be used for each Tag. If no chunk is given, array with available placeholders will be rendered\\n * &outTpl          string  optional    Name of a chunk that will be used for wrapping all tags. If no chunk is given, tags will be rendered without a wrapper\\n * &separator       string  optional    String separator, that will be used for separating Tags\\n * &limit           int     optional    Limit number of returned tag Tags\\n * &offset          int     optional    Offset the output by this number of Tags\\n * &totalPh         string  optional    Placeholder to output the total number of Tags regardless of &limit and &offset\\n * &target          int     optional    An ID of a resource that will be used for generating URI for a Tag. If no ID is given, current Resource ID will be used\\n * &showUnused      int     optional    If 1 is set, Tags that are not assigned to any Resource will be included to the output as well\\n * &showUnpublished int     optional    If 1 is set, Tags that are assigned only to unpublished Resources will be included to the output as well\\n * &showDeleted     int     optional    If 1 is set, Tags that are assigned only to deleted Resources will be included to the output as well\\n * &contexts        string  optional    If set, will display only tags for resources in given contexts. Contexts can be separated by a comma\\n * &toPlaceholder   string  optional    If set, output will return in placeholder with given name\\n * &sort            string  optional    Sort options in JSON. Example {\\"tag\\": \\"ASC\\"} or multiple sort options {\\"group_id\\": \\"ASC\\", \\"tag\\": \\"ASC\\"}\\n * &friendlyURL     int     optional    If set, will be used instead of friendly_urls system setting to generate URL\\n *\\n * USAGE:\\n *\\n * [[!TaggerGetTags? &showUnused=`1`]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\',\'Tagger\',$modx->getOption(\'tagger.core_path\',null,$modx->getOption(\'core_path\').\'components\\/tagger\\/\').\'model\\/tagger\\/\',$scriptProperties);\\nif (!($tagger instanceof Tagger)) return \'\';\\n\\n$resources = $modx->getOption(\'resources\', $scriptProperties, \'\');\\n$parents = $modx->getOption(\'parents\', $scriptProperties, \'\');\\n$groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n$target = (int) $modx->getOption(\'target\', $scriptProperties, $modx->resource->id, true);\\n$showUnused = (int) $modx->getOption(\'showUnused\', $scriptProperties, \'0\');\\n$showUnpublished = (int) $modx->getOption(\'showUnpublished\', $scriptProperties, \'0\');\\n$showDeleted = (int) $modx->getOption(\'showDeleted\', $scriptProperties, \'0\');\\n$contexts = $modx->getOption(\'contexts\', $scriptProperties, \'\');\\n$translate = (int) $modx->getOption(\'translate\', $scriptProperties, \'0\');\\n\\n$defaultRowTpl = $modx->getOption(\'rowTpl\', $scriptProperties, \'\');\\n$outTpl = $modx->getOption(\'outTpl\', $scriptProperties, \'\');\\n$wrapIfEmpty = $modx->getOption(\'wrapIfEmpty\', $scriptProperties, 1);\\n$separator = $modx->getOption(\'separator\', $scriptProperties, \'\');\\n$limit = intval($modx->getOption(\'limit\', $scriptProperties, 0));\\n$offset = intval($modx->getOption(\'offset\', $scriptProperties, 0));\\n$totalPh = $modx->getOption(\'totalPh\', $scriptProperties, \'tags_total\');\\n\\n$weight = (int) $modx->getOption(\'weight\', $scriptProperties, \'0\');\\n\\n$friendlyURL = $modx->getOption(\'friendlyURL\', $scriptProperties, $modx->getOption(\'friendly_urls\', null, 0));\\n\\n$sort = $modx->getOption(\'sort\', $scriptProperties, \'{}\');\\n$sort = $modx->fromJSON($sort);\\nif ($sort === null || $sort == \'\' || count($sort) == 0) {\\n    $sort = array(\\n        \'tag\' => \'ASC\'\\n    );\\n}\\n\\n$resources = $tagger->explodeAndClean($resources);\\n$parents = $tagger->explodeAndClean($parents);\\n$groups = $tagger->explodeAndClean($groups);\\n$contexts = $tagger->explodeAndClean($contexts);\\n$toPlaceholder = $modx->getOption(\'toPlaceholder\', $scriptProperties, \'\');\\n\\n$c = $modx->newQuery(\'TaggerTag\');\\n\\n$c->leftJoin(\'TaggerTagResource\', \'Resources\');\\n$c->leftJoin(\'TaggerGroup\', \'Group\');\\n$c->leftJoin(\'modResource\', \'Resource\', array(\'Resources.resource = Resource.id\'));\\n\\nif (!empty($parents)) {\\n    $c->where(array(\\n        \'Resource.parent:IN\' => $parents,\\n    ));\\n}\\n\\nif (!empty($contexts)) {\\n    $c->where(array(\\n        \'Resource.context_key:IN\' => $contexts,\\n    ));\\n}\\n\\nif ($showUnpublished == 0) {\\n    $c->where(array(\\n        \'Resource.published\' => 1,\\n        \'OR:Resource.published:IN\' => null,\\n    ));\\n}\\n\\nif ($showDeleted == 0) {\\n    $c->where(array(\\n        \'Resource.deleted\' => 0,\\n        \'OR:Resource.deleted:IS\' => null,\\n    ));\\n}\\n\\nif ($showUnused == 0) {\\n    $c->having(array(\\n        \'cnt > 0\',\\n    ));\\n}\\n\\nif (!empty($resources)) {\\n    $c->where(array(\\n        \'Resources.resource:IN\' => $resources\\n    ));\\n}\\n\\nif ($groups) {\\n    $c->where(array(\\n        \'Group.id:IN\' => $groups,\\n        \'OR:Group.name:IN\' => $groups,\\n        \'OR:Group.alias:IN\' => $groups,\\n    ));\\n}\\n$c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\'));\\n$c->select($modx->getSelectColumns(\'TaggerGroup\', \'Group\', \'group_\'));\\n$c->select(array(\'cnt\' => \'COUNT(Resources.tag)\'));\\n$c->groupby($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\') . \',\' . $modx->getSelectColumns(\'TaggerGroup\', \'Group\'));\\n\\n$c->prepare();\\n\\n$countQuery = new xPDOCriteria($modx, \\"SELECT COUNT(*) as total, MAX(cnt) as max_cnt FROM ({$c->toSQL(false)}) cq\\", $c->bindings, $c->cacheFlag);\\n$stmt = $countQuery->prepare();\\n\\nif ($stmt && $stmt->execute()) {\\n    $fetchedData = $stmt->fetch(PDO::FETCH_ASSOC);\\n    $total = intval($fetchedData[\'total\']);\\n    $maxCnt = intval($fetchedData[\'max_cnt\']);\\n} else {\\n    $total = 0;\\n    $maxCnt = 0;\\n}\\n\\n$modx->setPlaceholder($totalPh, $total);\\n\\nforeach ($sort as $field => $dir) {\\n    $dir = (strtolower($dir) == \'asc\') ? \'asc\' : \'desc\';\\n    $c->sortby($field, $dir);\\n}\\n\\n$c->limit($limit, $offset);\\n\\n$tags = $modx->getIterator(\'TaggerTag\', $c);\\n\\n$out = array();\\n\\n\\/\\/ prep for &tpl_N\\n$keys = array_keys($scriptProperties);\\n$nthTpls = array();\\nforeach($keys as $key) {\\n    $keyBits = $tagger->explodeAndClean($key, \'_\');\\n    if (isset($keyBits[0]) && $keyBits[0] === \'tpl\') {\\n        if ($i = (int) $keyBits[1]) $nthTpls[$i] = $scriptProperties[$key];\\n    }\\n}\\nksort($nthTpls);\\n\\n$idx = 1;\\n$currentTags = $tagger->getCurrentTags();\\n\\nforeach ($tags as $tag) {\\n    \\/** @var TaggerTag $tag *\\/\\n    $phs = $tag->toArray();\\n\\n    $group = $tag->Group;\\n\\n    if ($friendlyURL == 1) {\\n        $uri = rtrim($modx->makeUrl($target, \'\', \'\'), \'\\/\') . \'\\/\' . $group->alias . \'\\/\' . $tag->alias . \'\\/\';\\n    } else {\\n        $uri = $modx->makeUrl($target, \'\', $group->alias . \'=\' . $tag->alias);\\n    }\\n\\n    $phs[\'uri\'] = $uri;\\n    $phs[\'idx\'] = $idx;\\n    $phs[\'target\'] = $target;\\n    $phs[\'max_cnt\'] = $maxCnt;\\n    \\n    if (isset($currentTags[$group->alias][\'tags\'][$tag->alias])) {\\n        $phs[\'active\'] = 1;    \\n    } else {\\n        $phs[\'active\'] = 0;\\n    }\\n\\n    if ($weight > 0) {\\n        $phs[\'weight\'] = intval(ceil($phs[\'cnt\'] \\/ ($maxCnt \\/ $weight)));\\n    }\\n\\n    if ($translate == 1) {\\n        $groupNameTranslated = $modx->lexicon(\'tagger.custom.\' . $phs[\'group_alias\']);\\n        $groupDescriptionTranslated = $modx->lexicon(\'tagger.custom.\' . $phs[\'group_alias\'] . \'_desc\');\\n\\n        $phs[\'group_name_translated\'] = ($groupNameTranslated == \'tagger.custom.\' . $phs[\'group_alias\']) ? $phs[\'group_name\'] : $groupNameTranslated;\\n        $phs[\'group_description_translated\'] = ($groupDescriptionTranslated == \'tagger.custom.\' . $phs[\'group_alias\'] . \'_desc\') ? $phs[\'group_description\'] : $groupDescriptionTranslated;\\n    }\\n\\n    $rowTpl = $defaultRowTpl;\\n    $phs[\'sp\'] = $scriptProperties;\\n\\n    if ($rowTpl == \'\') {\\n        $out[] = \'<pre>\' . print_r($phs, true) . \'<\\/pre>\';\\n    } else {\\n        if (isset($nthTpls[$idx])) {\\n            $rowTpl = $nthTpls[$idx];\\n        } else {\\n            foreach ($nthTpls as $int => $tpl) {\\n                if ( ($idx % $int) === 0 ) $rowTpl = $tpl;\\n            }\\n        }\\n\\n        $out[] = $tagger->getChunk($rowTpl, $phs);\\n    }\\n\\n    $idx++;\\n}\\n\\n$out = implode($separator, $out);\\n\\nif ($outTpl != \'\') {\\n    if (!empty($out) || $wrapIfEmpty) {\\n        $noActiveTags = (int)(count($currentTags) === 0);\\n        $out = $tagger->getChunk($outTpl, array(\'tags\' => $out, \'sp\' => $scriptProperties, \'noActiveTags\' => $noActiveTags));\\n    }\\n}\\n\\nif (!empty($toPlaceholder)) {\\n    $modx->setPlaceholder($toPlaceholder, $out);\\n    return \'\';\\n}\\n\\nreturn $out;","locked":0,"properties":"a:15:{s:9:\\"resources\\";a:7:{s:4:\\"name\\";s:9:\\"resources\\";s:4:\\"desc\\";s:29:\\"tagger.gettags.resources_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"groups\\";a:7:{s:4:\\"name\\";s:6:\\"groups\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.groups_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"rowTpl\\";a:7:{s:4:\\"name\\";s:6:\\"rowTpl\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.rowTpl_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"outTpl\\";a:7:{s:4:\\"name\\";s:6:\\"outTpl\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.outTpl_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:9:\\"separator\\";a:7:{s:4:\\"name\\";s:9:\\"separator\\";s:4:\\"desc\\";s:29:\\"tagger.gettags.separator_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"target\\";a:7:{s:4:\\"name\\";s:6:\\"target\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.target_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:10:\\"showUnused\\";a:7:{s:4:\\"name\\";s:10:\\"showUnused\\";s:4:\\"desc\\";s:30:\\"tagger.gettags.showUnused_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:15:\\"showUnpublished\\";a:7:{s:4:\\"name\\";s:15:\\"showUnpublished\\";s:4:\\"desc\\";s:35:\\"tagger.gettags.showUnpublished_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:11:\\"showDeleted\\";a:7:{s:4:\\"name\\";s:11:\\"showDeleted\\";s:4:\\"desc\\";s:31:\\"tagger.gettags.showDeleted_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:8:\\"contexts\\";a:7:{s:4:\\"name\\";s:8:\\"contexts\\";s:4:\\"desc\\";s:28:\\"tagger.gettags.contexts_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:13:\\"toPlaceholder\\";a:7:{s:4:\\"name\\";s:13:\\"toPlaceholder\\";s:4:\\"desc\\";s:33:\\"tagger.gettags.toPlaceholder_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:5:\\"limit\\";a:7:{s:4:\\"name\\";s:5:\\"limit\\";s:4:\\"desc\\";s:25:\\"tagger.gettags.limit_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"offset\\";a:7:{s:4:\\"name\\";s:6:\\"offset\\";s:4:\\"desc\\";s:26:\\"tagger.gettags.offset_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:7:\\"totalPh\\";a:7:{s:4:\\"name\\";s:7:\\"totalPh\\";s:4:\\"desc\\";s:27:\\"tagger.gettags.totalPh_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:10:\\"tags_total\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:4:\\"sort\\";a:7:{s:4:\\"name\\";s:4:\\"sort\\";s:4:\\"desc\\";s:24:\\"tagger.gettags.sort_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:14:\\"{\\"tag\\": \\"asc\\"}\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * TaggerGetTags\\n *\\n * DESCRIPTION\\n *\\n * This Snippet allows you to list tags for resource(s), group(s) and all tags\\n *\\n * PROPERTIES:\\n *\\n * &resources       string  optional    Comma separated list of resources for which will be listed Tags\\n * &parents         string  optional    Comma separated list of parents for which will be listed Tags\\n * &groups          string  optional    Comma separated list of Tagger Groups for which will be listed Tags\\n * &rowTpl          string  optional    Name of a chunk that will be used for each Tag. If no chunk is given, array with available placeholders will be rendered\\n * &outTpl          string  optional    Name of a chunk that will be used for wrapping all tags. If no chunk is given, tags will be rendered without a wrapper\\n * &separator       string  optional    String separator, that will be used for separating Tags\\n * &limit           int     optional    Limit number of returned tag Tags\\n * &offset          int     optional    Offset the output by this number of Tags\\n * &totalPh         string  optional    Placeholder to output the total number of Tags regardless of &limit and &offset\\n * &target          int     optional    An ID of a resource that will be used for generating URI for a Tag. If no ID is given, current Resource ID will be used\\n * &showUnused      int     optional    If 1 is set, Tags that are not assigned to any Resource will be included to the output as well\\n * &showUnpublished int     optional    If 1 is set, Tags that are assigned only to unpublished Resources will be included to the output as well\\n * &showDeleted     int     optional    If 1 is set, Tags that are assigned only to deleted Resources will be included to the output as well\\n * &contexts        string  optional    If set, will display only tags for resources in given contexts. Contexts can be separated by a comma\\n * &toPlaceholder   string  optional    If set, output will return in placeholder with given name\\n * &sort            string  optional    Sort options in JSON. Example {\\"tag\\": \\"ASC\\"} or multiple sort options {\\"group_id\\": \\"ASC\\", \\"tag\\": \\"ASC\\"}\\n * &friendlyURL     int     optional    If set, will be used instead of friendly_urls system setting to generate URL\\n *\\n * USAGE:\\n *\\n * [[!TaggerGetTags? &showUnused=`1`]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\',\'Tagger\',$modx->getOption(\'tagger.core_path\',null,$modx->getOption(\'core_path\').\'components\\/tagger\\/\').\'model\\/tagger\\/\',$scriptProperties);\\nif (!($tagger instanceof Tagger)) return \'\';\\n\\n$resources = $modx->getOption(\'resources\', $scriptProperties, \'\');\\n$parents = $modx->getOption(\'parents\', $scriptProperties, \'\');\\n$groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n$target = (int) $modx->getOption(\'target\', $scriptProperties, $modx->resource->id, true);\\n$showUnused = (int) $modx->getOption(\'showUnused\', $scriptProperties, \'0\');\\n$showUnpublished = (int) $modx->getOption(\'showUnpublished\', $scriptProperties, \'0\');\\n$showDeleted = (int) $modx->getOption(\'showDeleted\', $scriptProperties, \'0\');\\n$contexts = $modx->getOption(\'contexts\', $scriptProperties, \'\');\\n$translate = (int) $modx->getOption(\'translate\', $scriptProperties, \'0\');\\n\\n$defaultRowTpl = $modx->getOption(\'rowTpl\', $scriptProperties, \'\');\\n$outTpl = $modx->getOption(\'outTpl\', $scriptProperties, \'\');\\n$wrapIfEmpty = $modx->getOption(\'wrapIfEmpty\', $scriptProperties, 1);\\n$separator = $modx->getOption(\'separator\', $scriptProperties, \'\');\\n$limit = intval($modx->getOption(\'limit\', $scriptProperties, 0));\\n$offset = intval($modx->getOption(\'offset\', $scriptProperties, 0));\\n$totalPh = $modx->getOption(\'totalPh\', $scriptProperties, \'tags_total\');\\n\\n$weight = (int) $modx->getOption(\'weight\', $scriptProperties, \'0\');\\n\\n$friendlyURL = $modx->getOption(\'friendlyURL\', $scriptProperties, $modx->getOption(\'friendly_urls\', null, 0));\\n\\n$sort = $modx->getOption(\'sort\', $scriptProperties, \'{}\');\\n$sort = $modx->fromJSON($sort);\\nif ($sort === null || $sort == \'\' || count($sort) == 0) {\\n    $sort = array(\\n        \'tag\' => \'ASC\'\\n    );\\n}\\n\\n$resources = $tagger->explodeAndClean($resources);\\n$parents = $tagger->explodeAndClean($parents);\\n$groups = $tagger->explodeAndClean($groups);\\n$contexts = $tagger->explodeAndClean($contexts);\\n$toPlaceholder = $modx->getOption(\'toPlaceholder\', $scriptProperties, \'\');\\n\\n$c = $modx->newQuery(\'TaggerTag\');\\n\\n$c->leftJoin(\'TaggerTagResource\', \'Resources\');\\n$c->leftJoin(\'TaggerGroup\', \'Group\');\\n$c->leftJoin(\'modResource\', \'Resource\', array(\'Resources.resource = Resource.id\'));\\n\\nif (!empty($parents)) {\\n    $c->where(array(\\n        \'Resource.parent:IN\' => $parents,\\n    ));\\n}\\n\\nif (!empty($contexts)) {\\n    $c->where(array(\\n        \'Resource.context_key:IN\' => $contexts,\\n    ));\\n}\\n\\nif ($showUnpublished == 0) {\\n    $c->where(array(\\n        \'Resource.published\' => 1,\\n        \'OR:Resource.published:IN\' => null,\\n    ));\\n}\\n\\nif ($showDeleted == 0) {\\n    $c->where(array(\\n        \'Resource.deleted\' => 0,\\n        \'OR:Resource.deleted:IS\' => null,\\n    ));\\n}\\n\\nif ($showUnused == 0) {\\n    $c->having(array(\\n        \'cnt > 0\',\\n    ));\\n}\\n\\nif (!empty($resources)) {\\n    $c->where(array(\\n        \'Resources.resource:IN\' => $resources\\n    ));\\n}\\n\\nif ($groups) {\\n    $c->where(array(\\n        \'Group.id:IN\' => $groups,\\n        \'OR:Group.name:IN\' => $groups,\\n        \'OR:Group.alias:IN\' => $groups,\\n    ));\\n}\\n$c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\'));\\n$c->select($modx->getSelectColumns(\'TaggerGroup\', \'Group\', \'group_\'));\\n$c->select(array(\'cnt\' => \'COUNT(Resources.tag)\'));\\n$c->groupby($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\') . \',\' . $modx->getSelectColumns(\'TaggerGroup\', \'Group\'));\\n\\n$c->prepare();\\n\\n$countQuery = new xPDOCriteria($modx, \\"SELECT COUNT(*) as total, MAX(cnt) as max_cnt FROM ({$c->toSQL(false)}) cq\\", $c->bindings, $c->cacheFlag);\\n$stmt = $countQuery->prepare();\\n\\nif ($stmt && $stmt->execute()) {\\n    $fetchedData = $stmt->fetch(PDO::FETCH_ASSOC);\\n    $total = intval($fetchedData[\'total\']);\\n    $maxCnt = intval($fetchedData[\'max_cnt\']);\\n} else {\\n    $total = 0;\\n    $maxCnt = 0;\\n}\\n\\n$modx->setPlaceholder($totalPh, $total);\\n\\nforeach ($sort as $field => $dir) {\\n    $dir = (strtolower($dir) == \'asc\') ? \'asc\' : \'desc\';\\n    $c->sortby($field, $dir);\\n}\\n\\n$c->limit($limit, $offset);\\n\\n$tags = $modx->getIterator(\'TaggerTag\', $c);\\n\\n$out = array();\\n\\n\\/\\/ prep for &tpl_N\\n$keys = array_keys($scriptProperties);\\n$nthTpls = array();\\nforeach($keys as $key) {\\n    $keyBits = $tagger->explodeAndClean($key, \'_\');\\n    if (isset($keyBits[0]) && $keyBits[0] === \'tpl\') {\\n        if ($i = (int) $keyBits[1]) $nthTpls[$i] = $scriptProperties[$key];\\n    }\\n}\\nksort($nthTpls);\\n\\n$idx = 1;\\n$currentTags = $tagger->getCurrentTags();\\n\\nforeach ($tags as $tag) {\\n    \\/** @var TaggerTag $tag *\\/\\n    $phs = $tag->toArray();\\n\\n    $group = $tag->Group;\\n\\n    if ($friendlyURL == 1) {\\n        $uri = rtrim($modx->makeUrl($target, \'\', \'\'), \'\\/\') . \'\\/\' . $group->alias . \'\\/\' . $tag->alias . \'\\/\';\\n    } else {\\n        $uri = $modx->makeUrl($target, \'\', $group->alias . \'=\' . $tag->alias);\\n    }\\n\\n    $phs[\'uri\'] = $uri;\\n    $phs[\'idx\'] = $idx;\\n    $phs[\'target\'] = $target;\\n    $phs[\'max_cnt\'] = $maxCnt;\\n    \\n    if (isset($currentTags[$group->alias][\'tags\'][$tag->alias])) {\\n        $phs[\'active\'] = 1;    \\n    } else {\\n        $phs[\'active\'] = 0;\\n    }\\n\\n    if ($weight > 0) {\\n        $phs[\'weight\'] = intval(ceil($phs[\'cnt\'] \\/ ($maxCnt \\/ $weight)));\\n    }\\n\\n    if ($translate == 1) {\\n        $groupNameTranslated = $modx->lexicon(\'tagger.custom.\' . $phs[\'group_alias\']);\\n        $groupDescriptionTranslated = $modx->lexicon(\'tagger.custom.\' . $phs[\'group_alias\'] . \'_desc\');\\n\\n        $phs[\'group_name_translated\'] = ($groupNameTranslated == \'tagger.custom.\' . $phs[\'group_alias\']) ? $phs[\'group_name\'] : $groupNameTranslated;\\n        $phs[\'group_description_translated\'] = ($groupDescriptionTranslated == \'tagger.custom.\' . $phs[\'group_alias\'] . \'_desc\') ? $phs[\'group_description\'] : $groupDescriptionTranslated;\\n    }\\n\\n    $rowTpl = $defaultRowTpl;\\n    $phs[\'sp\'] = $scriptProperties;\\n\\n    if ($rowTpl == \'\') {\\n        $out[] = \'<pre>\' . print_r($phs, true) . \'<\\/pre>\';\\n    } else {\\n        if (isset($nthTpls[$idx])) {\\n            $rowTpl = $nthTpls[$idx];\\n        } else {\\n            foreach ($nthTpls as $int => $tpl) {\\n                if ( ($idx % $int) === 0 ) $rowTpl = $tpl;\\n            }\\n        }\\n\\n        $out[] = $tagger->getChunk($rowTpl, $phs);\\n    }\\n\\n    $idx++;\\n}\\n\\n$out = implode($separator, $out);\\n\\nif ($outTpl != \'\') {\\n    if (!empty($out) || $wrapIfEmpty) {\\n        $noActiveTags = (int)(count($currentTags) === 0);\\n        $out = $tagger->getChunk($outTpl, array(\'tags\' => $out, \'sp\' => $scriptProperties, \'noActiveTags\' => $noActiveTags));\\n    }\\n}\\n\\nif (!empty($toPlaceholder)) {\\n    $modx->setPlaceholder($toPlaceholder, $out);\\n    return \'\';\\n}\\n\\nreturn $out;"}',
        'guid' => '1fff127967eb257a69390b4b43be7fc0',
        'native_key' => NULL,
        'signature' => '927b23d062863a4fb08c29d5244dfa1e',
      ),
      'c5a8b01f4e65d240ae3f12f28f16b275' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"TaggerGetResourcesWhere","description":"","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * TaggerGetResourcesWhere\\n *\\n * DESCRIPTION\\n *\\n * This snippet generate SQL Query that can be used in WHERE condition in getResources snippet\\n *\\n * PROPERTIES:\\n *\\n * &tags            string  optional    Comma separated list of Tags for which will be generated a Resource query. By default Tags from GET param will be loaded\\n * &groups          string  optional    Comma separated list of Tagger Groups. Only from those groups will Tags be allowed\\n * &where           string  optional    Original getResources where property. If you used where property in your current getResources call, move it here\\n * &likeComparison  int     optional    If set to 1, tags will compare using LIKE\\n * &tagField        string  optional    Field that will be used to compare with given tags. Default: alias\\n * &matchAll        int     optional    If set to 1, resource must have all specified tags. Default: 0\\n * &field           string  optional    modResource field that will be used to compare with assigned resource ID\\n *\\n * USAGE:\\n *\\n * [[!getResources? &where=`[[!TaggerGetResourcesWhere? &tags=`Books,Vehicles` &where=`{\\"isfolder\\": 0}`]]`]]\\n *\\n *\\/\\n\\n$tagger = $modx->getService(\'tagger\',\'Tagger\',$modx->getOption(\'tagger.core_path\',null,$modx->getOption(\'core_path\').\'components\\/tagger\\/\').\'model\\/tagger\\/\',$scriptProperties);\\nif (!($tagger instanceof Tagger)) return \'\';\\n\\n$tags = $modx->getOption(\'tags\', $scriptProperties, \'\');\\n$where = $modx->getOption(\'where\', $scriptProperties, \'\');\\n$tagField = $modx->getOption(\'tagField\', $scriptProperties, \'alias\');\\n$likeComparison = (int) $modx->getOption(\'likeComparison\', $scriptProperties, 0);\\n$matchAll = (int) $modx->getOption(\'matchAll\', $scriptProperties, 0);\\n$field = $modx->getOption(\'field\', $scriptProperties, \'id\');\\n$where = $modx->fromJSON($where);\\nif ($where == false) {\\n    $where = array();\\n}\\n\\n$tagsCount = 0;\\n\\nif ($tags == \'\') {\\n    $gc = $modx->newQuery(\'TaggerGroup\');\\n    $gc->select($modx->getSelectColumns(\'TaggerGroup\', \'\', \'\', array(\'alias\')));\\n\\n    $groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n    $groups = $tagger->explodeAndClean($groups);\\n    if (!empty($groups)) {\\n        $gc->where(array(\\n            \'name:IN\' => $groups,\\n            \'OR:alias:IN\' => $groups,\\n            \'OR:id:IN\' => $groups,\\n        ));\\n    }\\n\\n    $gc->prepare();\\n    $gc->stmt->execute();\\n    $groups = $gc->stmt->fetchAll(PDO::FETCH_COLUMN, 0);\\n\\n    $conditions = array();\\n    foreach ($groups as $group) {\\n        if (isset($_GET[$group])) {\\n            $groupTags = $tagger->explodeAndClean($_GET[$group]);\\n            if (!empty($groupTags)) {\\n                $like = array(\'AND:alias:IN\' => $groupTags);\\n\\n                if ($likeComparison == 1) {\\n                    foreach ($groupTags as $tag) {\\n                        $like[] = array(\'OR:alias:LIKE\' => \'%\' . $tag . \'%\');\\n                    }\\n                }\\n\\n                $conditions[] = array(\\n                    \'OR:Group.alias:=\' => $group,\\n                    $like\\n                );\\n                $tagsCount += count($groupTags);\\n            }\\n        }\\n    }\\n\\n    if (count($conditions) == 0) {\\n        return $modx->toJSON($where);\\n    }\\n\\n    $c = $modx->newQuery(\'TaggerTag\');\\n    $c->leftJoin(\'TaggerGroup\', \'Group\');\\n\\n    $c->where($conditions);\\n} else {\\n    $tags = $tagger->explodeAndClean($tags);\\n\\n    if (empty($tags)) {\\n        return $modx->toJSON($where);\\n    }\\n\\n    $tagsCount = count($tags);\\n\\n    $groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n\\n    $groups = $tagger->explodeAndClean($groups);\\n\\n    $c = $modx->newQuery(\'TaggerTag\');\\n    $c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\', \'\', array(\'id\')));\\n\\n    $compare = array(\\n        $tagField . \':IN\' => $tags\\n    );\\n\\n    if ($likeComparison == 1) {\\n        foreach ($tags as $tag) {\\n            $compare[] = array(\'OR:\' . $tagField . \':LIKE\' => \'%\' . $tag . \'%\');\\n        }\\n    }\\n\\n    $c->where($compare);\\n\\n    if (!empty($groups)) {\\n        $c->leftJoin(\'TaggerGroup\', \'Group\');\\n        $c->where(array(\\n            \'Group.id:IN\' => $groups,\\n            \'OR:Group.name:IN\' => $groups,\\n            \'OR:Group.alias:IN\' => $groups,\\n        ));\\n    }\\n}\\n\\n$c->prepare();\\n$c->stmt->execute();\\n$tagIDs = $c->stmt->fetchAll(PDO::FETCH_COLUMN, 0);\\n\\nif (count($tagIDs) == 0) {\\n    $tagIDs[] = 0;\\n}\\n\\nif ($matchAll == 0) {\\n    $where[] = \\"EXISTS (SELECT 1 FROM {$modx->getTableName(\'TaggerTagResource\')} r WHERE r.tag IN (\\" . implode(\',\', $tagIDs) . \\") AND r.resource = modResource.\\" . $field . \\")\\";\\n} else {\\n    $where[] = \\"EXISTS (SELECT 1 as found FROM {$modx->getTableName(\'TaggerTagResource\')} r WHERE r.tag IN (\\" . implode(\',\', $tagIDs) . \\") AND r.resource = modResource.\\" . $field . \\" GROUP BY found HAVING count(found) = \\" . $tagsCount . \\")\\";\\n}\\n\\nreturn $modx->toJSON($where);","locked":0,"properties":"a:6:{s:4:\\"tags\\";a:7:{s:4:\\"name\\";s:4:\\"tags\\";s:4:\\"desc\\";s:34:\\"tagger.getresourceswhere.tags_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:6:\\"groups\\";a:7:{s:4:\\"name\\";s:6:\\"groups\\";s:4:\\"desc\\";s:36:\\"tagger.getresourceswhere.groups_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:5:\\"where\\";a:7:{s:4:\\"name\\";s:5:\\"where\\";s:4:\\"desc\\";s:35:\\"tagger.getresourceswhere.where_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:0:\\"\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:14:\\"likeComparison\\";a:7:{s:4:\\"name\\";s:14:\\"likeComparison\\";s:4:\\"desc\\";s:44:\\"tagger.getresourceswhere.likeComparison_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:8:\\"tagField\\";a:7:{s:4:\\"name\\";s:8:\\"tagField\\";s:4:\\"desc\\";s:38:\\"tagger.getresourceswhere.tagField_desc\\";s:4:\\"type\\";s:9:\\"textfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:5:\\"alias\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}s:8:\\"matchAll\\";a:7:{s:4:\\"name\\";s:8:\\"matchAll\\";s:4:\\"desc\\";s:38:\\"tagger.getresourceswhere.matchAll_desc\\";s:4:\\"type\\";s:11:\\"numberfield\\";s:7:\\"options\\";s:0:\\"\\";s:5:\\"value\\";s:1:\\"0\\";s:7:\\"lexicon\\";s:17:\\"tagger:properties\\";s:4:\\"area\\";s:0:\\"\\";}}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * TaggerGetResourcesWhere\\n *\\n * DESCRIPTION\\n *\\n * This snippet generate SQL Query that can be used in WHERE condition in getResources snippet\\n *\\n * PROPERTIES:\\n *\\n * &tags            string  optional    Comma separated list of Tags for which will be generated a Resource query. By default Tags from GET param will be loaded\\n * &groups          string  optional    Comma separated list of Tagger Groups. Only from those groups will Tags be allowed\\n * &where           string  optional    Original getResources where property. If you used where property in your current getResources call, move it here\\n * &likeComparison  int     optional    If set to 1, tags will compare using LIKE\\n * &tagField        string  optional    Field that will be used to compare with given tags. Default: alias\\n * &matchAll        int     optional    If set to 1, resource must have all specified tags. Default: 0\\n * &field           string  optional    modResource field that will be used to compare with assigned resource ID\\n *\\n * USAGE:\\n *\\n * [[!getResources? &where=`[[!TaggerGetResourcesWhere? &tags=`Books,Vehicles` &where=`{\\"isfolder\\": 0}`]]`]]\\n *\\n *\\/\\n\\n$tagger = $modx->getService(\'tagger\',\'Tagger\',$modx->getOption(\'tagger.core_path\',null,$modx->getOption(\'core_path\').\'components\\/tagger\\/\').\'model\\/tagger\\/\',$scriptProperties);\\nif (!($tagger instanceof Tagger)) return \'\';\\n\\n$tags = $modx->getOption(\'tags\', $scriptProperties, \'\');\\n$where = $modx->getOption(\'where\', $scriptProperties, \'\');\\n$tagField = $modx->getOption(\'tagField\', $scriptProperties, \'alias\');\\n$likeComparison = (int) $modx->getOption(\'likeComparison\', $scriptProperties, 0);\\n$matchAll = (int) $modx->getOption(\'matchAll\', $scriptProperties, 0);\\n$field = $modx->getOption(\'field\', $scriptProperties, \'id\');\\n$where = $modx->fromJSON($where);\\nif ($where == false) {\\n    $where = array();\\n}\\n\\n$tagsCount = 0;\\n\\nif ($tags == \'\') {\\n    $gc = $modx->newQuery(\'TaggerGroup\');\\n    $gc->select($modx->getSelectColumns(\'TaggerGroup\', \'\', \'\', array(\'alias\')));\\n\\n    $groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n    $groups = $tagger->explodeAndClean($groups);\\n    if (!empty($groups)) {\\n        $gc->where(array(\\n            \'name:IN\' => $groups,\\n            \'OR:alias:IN\' => $groups,\\n            \'OR:id:IN\' => $groups,\\n        ));\\n    }\\n\\n    $gc->prepare();\\n    $gc->stmt->execute();\\n    $groups = $gc->stmt->fetchAll(PDO::FETCH_COLUMN, 0);\\n\\n    $conditions = array();\\n    foreach ($groups as $group) {\\n        if (isset($_GET[$group])) {\\n            $groupTags = $tagger->explodeAndClean($_GET[$group]);\\n            if (!empty($groupTags)) {\\n                $like = array(\'AND:alias:IN\' => $groupTags);\\n\\n                if ($likeComparison == 1) {\\n                    foreach ($groupTags as $tag) {\\n                        $like[] = array(\'OR:alias:LIKE\' => \'%\' . $tag . \'%\');\\n                    }\\n                }\\n\\n                $conditions[] = array(\\n                    \'OR:Group.alias:=\' => $group,\\n                    $like\\n                );\\n                $tagsCount += count($groupTags);\\n            }\\n        }\\n    }\\n\\n    if (count($conditions) == 0) {\\n        return $modx->toJSON($where);\\n    }\\n\\n    $c = $modx->newQuery(\'TaggerTag\');\\n    $c->leftJoin(\'TaggerGroup\', \'Group\');\\n\\n    $c->where($conditions);\\n} else {\\n    $tags = $tagger->explodeAndClean($tags);\\n\\n    if (empty($tags)) {\\n        return $modx->toJSON($where);\\n    }\\n\\n    $tagsCount = count($tags);\\n\\n    $groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n\\n    $groups = $tagger->explodeAndClean($groups);\\n\\n    $c = $modx->newQuery(\'TaggerTag\');\\n    $c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\', \'\', array(\'id\')));\\n\\n    $compare = array(\\n        $tagField . \':IN\' => $tags\\n    );\\n\\n    if ($likeComparison == 1) {\\n        foreach ($tags as $tag) {\\n            $compare[] = array(\'OR:\' . $tagField . \':LIKE\' => \'%\' . $tag . \'%\');\\n        }\\n    }\\n\\n    $c->where($compare);\\n\\n    if (!empty($groups)) {\\n        $c->leftJoin(\'TaggerGroup\', \'Group\');\\n        $c->where(array(\\n            \'Group.id:IN\' => $groups,\\n            \'OR:Group.name:IN\' => $groups,\\n            \'OR:Group.alias:IN\' => $groups,\\n        ));\\n    }\\n}\\n\\n$c->prepare();\\n$c->stmt->execute();\\n$tagIDs = $c->stmt->fetchAll(PDO::FETCH_COLUMN, 0);\\n\\nif (count($tagIDs) == 0) {\\n    $tagIDs[] = 0;\\n}\\n\\nif ($matchAll == 0) {\\n    $where[] = \\"EXISTS (SELECT 1 FROM {$modx->getTableName(\'TaggerTagResource\')} r WHERE r.tag IN (\\" . implode(\',\', $tagIDs) . \\") AND r.resource = modResource.\\" . $field . \\")\\";\\n} else {\\n    $where[] = \\"EXISTS (SELECT 1 as found FROM {$modx->getTableName(\'TaggerTagResource\')} r WHERE r.tag IN (\\" . implode(\',\', $tagIDs) . \\") AND r.resource = modResource.\\" . $field . \\" GROUP BY found HAVING count(found) = \\" . $tagsCount . \\")\\";\\n}\\n\\nreturn $modx->toJSON($where);"}',
        'guid' => '561e443bcc8765548bd5d20250806568',
        'native_key' => NULL,
        'signature' => 'ea00726237f0fddddfb0c10171c9e882',
      ),
      'f1f21058899dd8900c93bb42fa1bdac7' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"TaggerGetRelatedWhere","description":"","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * TaggerGetRelatedWhere\\n *\\n * DESCRIPTION\\n *\\n * This snippet generates a SQL Query that can be used in WHERE condition in getResources snippet\\n * to get related resources, which have the same tags \\n *\\n * PROPERTIES:\\n *\\n * &resources       string  optional    Comma separated list of resources for which will be listed Tags. Default: current resource\\n * &groups          string  optional    Comma separated list of Tagger Groups for which will be listed Tags\\n * &showUnused      int     optional    If 1 is set, Tags that are not assigned to any Resource will be included to the output as well\\n * &showUnpublished int     optional    If 1 is set, Tags that are assigned only to unpublished Resources will be included to the output as well\\n * &showDeleted     int     optional    If 1 is set, Tags that are assigned only to deleted Resources will be included to the output as well\\n * &contexts        string  optional    If set, will display only tags for resources in given contexts. Contexts can be separated by a comma\\n * \\n * TaggerGetResourcesWhere - PROPERTIES:\\n * \\n * &tags            string  optional    Comma separated list of Tags for which will be generated a Resource query. By default Tags from GET param will be loaded\\n * &groups          string  optional    Comma separated list of Tagger Groups. Only from those groups will Tags be allowed\\n * &where           string  optional    Original getResources where property. If you used where property in your current getResources call, move it here\\n * &likeComparison  int     optional    If set to 1, tags will compare using LIKE\\n * &tagField        string  optional    Field that will be used to compare with given tags. Default: alias\\n * &matchAll        int     optional    If set to 1, resource must have all specified tags. Default: 0 \\n *\\n * USAGE:\\n *\\n * [[!TaggerGetRelatedWhere? &groups=`1` ]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\', \'Tagger\', $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/tagger\\/\') . \'model\\/tagger\\/\', $scriptProperties);\\nif (!($tagger instanceof Tagger))\\n    return \'\';\\n\\n$resources = $modx->getOption(\'resources\', $scriptProperties, is_object($modx->resource) ? $modx->resource->get(\'id\') : \'\');\\n$groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n$showUnused = (int)$modx->getOption(\'showUnused\', $scriptProperties, \'0\');\\n$showUnpublished = (int)$modx->getOption(\'showUnpublished\', $scriptProperties, \'0\');\\n$showDeleted = (int)$modx->getOption(\'showDeleted\', $scriptProperties, \'0\');\\n$contexts = $modx->getOption(\'contexts\', $scriptProperties, \'\');\\n\\n$totalPh = $modx->getOption(\'totalPh\', $scriptProperties, \'tags_total\');\\n\\n$resources = $tagger->explodeAndClean($resources);\\n$groups = $tagger->explodeAndClean($groups);\\n$contexts = $tagger->explodeAndClean($contexts);\\n\\n$c = $modx->newQuery(\'TaggerTag\');\\n\\n$c->leftJoin(\'TaggerTagResource\', \'Resources\');\\n$c->leftJoin(\'TaggerGroup\', \'Group\');\\n$c->leftJoin(\'modResource\', \'Resource\', array(\'Resources.resource = Resource.id\'));\\n\\n\\nif (!empty($contexts)) {\\n    $c->where(array(\'Resource.context_key:IN\' => $contexts, ));\\n}\\n\\nif ($showUnpublished == 0) {\\n    $c->where(array(\\n        \'Resource.published\' => 1,\\n        \'OR:Resource.published:IN\' => null,\\n        ));\\n}\\n\\nif ($showDeleted == 0) {\\n    $c->where(array(\\n        \'Resource.deleted\' => 0,\\n        \'OR:Resource.deleted:IS\' => null,\\n        ));\\n}\\n\\nif ($showUnused == 0) {\\n    $c->having(array(\'cnt > 0\', ));\\n}\\n\\nif ($resources) {\\n    $c->where(array(\'Resources.resource:IN\' => $resources));\\n}\\n\\nif ($groups) {\\n    $c->where(array(\\n        \'Group.id:IN\' => $groups,\\n        \'OR:Group.name:IN\' => $groups,\\n        \'OR:Group.alias:IN\' => $groups,\\n        ));\\n}\\n$c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\'));\\n\\/\\/$c->select($modx->getSelectColumns(\'TaggerGroup\', \'Group\', \'group_\'));\\n$c->select(array(\'cnt\' => \'COUNT(Resources.tag)\'));\\n$c->groupby($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\') . \',\' . $modx->getSelectColumns(\'TaggerGroup\', \'Group\'));\\n\\n$c->prepare();\\n$countQuery = new xPDOCriteria($modx, \\"SELECT COUNT(*) FROM ({$c->toSQL(false)}) cq\\", $c->bindings, $c->cacheFlag);\\n$stmt = $countQuery->prepare();\\nif ($stmt && $stmt->execute()) {\\n    $total = intval($stmt->fetchColumn());\\n} else {\\n    $total = 0;\\n}\\n\\n$modx->setPlaceholder($totalPh, $total);\\n\\n$tags = array();\\n\\nif ($collection = $modx->getIterator(\'TaggerTag\', $c)) {\\n    foreach ($collection as $tag) {\\n        $tags[] = $tag->get(\'alias\');\\n    }\\n}\\n\\n$wherecondition = array(\'id:not IN\' => $resources);\\n\\n$scriptProperties[\'where\'] = $modx->toJson($wherecondition);\\n\\n$output = \'{\\"template\\":\\"99999999\\"}\';\\n\\nif (count($tags)) {\\n    $scriptProperties[\'tags\'] = implode(\',\', $tags);\\n    $output = $modx->runSnippet(\'TaggerGetResourcesWhere\', $scriptProperties);\\n}\\n\\nreturn $output;","locked":0,"properties":"a:0:{}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * TaggerGetRelatedWhere\\n *\\n * DESCRIPTION\\n *\\n * This snippet generates a SQL Query that can be used in WHERE condition in getResources snippet\\n * to get related resources, which have the same tags \\n *\\n * PROPERTIES:\\n *\\n * &resources       string  optional    Comma separated list of resources for which will be listed Tags. Default: current resource\\n * &groups          string  optional    Comma separated list of Tagger Groups for which will be listed Tags\\n * &showUnused      int     optional    If 1 is set, Tags that are not assigned to any Resource will be included to the output as well\\n * &showUnpublished int     optional    If 1 is set, Tags that are assigned only to unpublished Resources will be included to the output as well\\n * &showDeleted     int     optional    If 1 is set, Tags that are assigned only to deleted Resources will be included to the output as well\\n * &contexts        string  optional    If set, will display only tags for resources in given contexts. Contexts can be separated by a comma\\n * \\n * TaggerGetResourcesWhere - PROPERTIES:\\n * \\n * &tags            string  optional    Comma separated list of Tags for which will be generated a Resource query. By default Tags from GET param will be loaded\\n * &groups          string  optional    Comma separated list of Tagger Groups. Only from those groups will Tags be allowed\\n * &where           string  optional    Original getResources where property. If you used where property in your current getResources call, move it here\\n * &likeComparison  int     optional    If set to 1, tags will compare using LIKE\\n * &tagField        string  optional    Field that will be used to compare with given tags. Default: alias\\n * &matchAll        int     optional    If set to 1, resource must have all specified tags. Default: 0 \\n *\\n * USAGE:\\n *\\n * [[!TaggerGetRelatedWhere? &groups=`1` ]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\', \'Tagger\', $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/tagger\\/\') . \'model\\/tagger\\/\', $scriptProperties);\\nif (!($tagger instanceof Tagger))\\n    return \'\';\\n\\n$resources = $modx->getOption(\'resources\', $scriptProperties, is_object($modx->resource) ? $modx->resource->get(\'id\') : \'\');\\n$groups = $modx->getOption(\'groups\', $scriptProperties, \'\');\\n$showUnused = (int)$modx->getOption(\'showUnused\', $scriptProperties, \'0\');\\n$showUnpublished = (int)$modx->getOption(\'showUnpublished\', $scriptProperties, \'0\');\\n$showDeleted = (int)$modx->getOption(\'showDeleted\', $scriptProperties, \'0\');\\n$contexts = $modx->getOption(\'contexts\', $scriptProperties, \'\');\\n\\n$totalPh = $modx->getOption(\'totalPh\', $scriptProperties, \'tags_total\');\\n\\n$resources = $tagger->explodeAndClean($resources);\\n$groups = $tagger->explodeAndClean($groups);\\n$contexts = $tagger->explodeAndClean($contexts);\\n\\n$c = $modx->newQuery(\'TaggerTag\');\\n\\n$c->leftJoin(\'TaggerTagResource\', \'Resources\');\\n$c->leftJoin(\'TaggerGroup\', \'Group\');\\n$c->leftJoin(\'modResource\', \'Resource\', array(\'Resources.resource = Resource.id\'));\\n\\n\\nif (!empty($contexts)) {\\n    $c->where(array(\'Resource.context_key:IN\' => $contexts, ));\\n}\\n\\nif ($showUnpublished == 0) {\\n    $c->where(array(\\n        \'Resource.published\' => 1,\\n        \'OR:Resource.published:IN\' => null,\\n        ));\\n}\\n\\nif ($showDeleted == 0) {\\n    $c->where(array(\\n        \'Resource.deleted\' => 0,\\n        \'OR:Resource.deleted:IS\' => null,\\n        ));\\n}\\n\\nif ($showUnused == 0) {\\n    $c->having(array(\'cnt > 0\', ));\\n}\\n\\nif ($resources) {\\n    $c->where(array(\'Resources.resource:IN\' => $resources));\\n}\\n\\nif ($groups) {\\n    $c->where(array(\\n        \'Group.id:IN\' => $groups,\\n        \'OR:Group.name:IN\' => $groups,\\n        \'OR:Group.alias:IN\' => $groups,\\n        ));\\n}\\n$c->select($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\'));\\n\\/\\/$c->select($modx->getSelectColumns(\'TaggerGroup\', \'Group\', \'group_\'));\\n$c->select(array(\'cnt\' => \'COUNT(Resources.tag)\'));\\n$c->groupby($modx->getSelectColumns(\'TaggerTag\', \'TaggerTag\') . \',\' . $modx->getSelectColumns(\'TaggerGroup\', \'Group\'));\\n\\n$c->prepare();\\n$countQuery = new xPDOCriteria($modx, \\"SELECT COUNT(*) FROM ({$c->toSQL(false)}) cq\\", $c->bindings, $c->cacheFlag);\\n$stmt = $countQuery->prepare();\\nif ($stmt && $stmt->execute()) {\\n    $total = intval($stmt->fetchColumn());\\n} else {\\n    $total = 0;\\n}\\n\\n$modx->setPlaceholder($totalPh, $total);\\n\\n$tags = array();\\n\\nif ($collection = $modx->getIterator(\'TaggerTag\', $c)) {\\n    foreach ($collection as $tag) {\\n        $tags[] = $tag->get(\'alias\');\\n    }\\n}\\n\\n$wherecondition = array(\'id:not IN\' => $resources);\\n\\n$scriptProperties[\'where\'] = $modx->toJson($wherecondition);\\n\\n$output = \'{\\"template\\":\\"99999999\\"}\';\\n\\nif (count($tags)) {\\n    $scriptProperties[\'tags\'] = implode(\',\', $tags);\\n    $output = $modx->runSnippet(\'TaggerGetResourcesWhere\', $scriptProperties);\\n}\\n\\nreturn $output;"}',
        'guid' => 'e345f6a02b2f7939b6b06f1593ed3433',
        'native_key' => NULL,
        'signature' => 'cf45ce48c76500a9cde42fa989054b77',
      ),
      '8f1e4560a63212a47910efc274ea980b' => 
      array (
        'preserve_keys' => false,
        'update_object' => true,
        'unique_key' => 'name',
        'class' => 'modSnippet',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"TaggerGetCurrentTag","description":"","editor_type":0,"category":0,"cache_type":0,"snippet":"\\/**\\n * TaggerGetCurrentTag\\n *\\n * DESCRIPTION\\n *\\n *\\n * PROPERTIES:\\n * \\n * &tagTpl          string  optional    Name of a chunk that will be used for each Tag. If no chunk is given, array with available placeholders will be rendered\\n * &groupTpl        string  optional    Name of a chunk that will be used for each Tag. If no chunk is given, array with available placeholders will be rendered\\n * &tagSeparator    string  optional    String separator, that will be used for separating Tags\\n * &groupSeparator  string  optional    String separator, that will be used for separating Groups\\n *\\n * USAGE:\\n *\\n * [[!TaggerGetCurrentTag? &groupTpl=`currentGroup` &tagTpl=`@INLINE [[+tag]]` &tagSeparator=`, ` ]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\', \'Tagger\', $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/tagger\\/\') . \'model\\/tagger\\/\', $scriptProperties);\\nif (!($tagger instanceof Tagger))\\n    return \'\';\\n\\n$tagTpl = $modx->getOption(\'tagTpl\', $scriptProperties, \'\');\\n$groupTpl = $modx->getOption(\'groupTpl\', $scriptProperties, \'\');\\n$tagSeparator = $modx->getOption(\'tagSeparator\', $scriptProperties, \'\');\\n$groupSeparator = $modx->getOption(\'groupSeparator\', $scriptProperties, \'\');\\n\\n$currentTags = $tagger->getCurrentTags();\\n\\n$output = array();\\n\\nforeach ($currentTags as $currentTag) {\\n    if (!isset($currentTag[\'tags\'])) continue;\\n\\n    $tags = array();\\n    foreach ($currentTag[\'tags\'] as $tag) {\\n        $phs = array (\\n            \'tag\' => $tag[\'tag\'],\\n            \'alias\' => $tag[\'alias\'],\\n            \'group_name\' => $currentTag[\'group\'],\\n            \'group_alias\' => $currentTag[\'alias\'],\\n        );\\n\\n        if (empty($tagTpl)) {\\n            $tags[] = \'<pre>\' . print_r($phs, true) . \'<\\/pre>\';\\n        } else {\\n            $tags[] = $tagger->getChunk($tagTpl, $phs);\\n        }\\n    }\\n    \\n    $groupPhs = array(\\n        \'name\' => $currentTag[\'group\'],\\n        \'alias\' => $currentTag[\'alias\'],\\n        \'multipleTags\' => intval(count($tags) > 1),\\n        \'tags\' => implode($tagSeparator, $tags)\\n    );\\n\\n    if (empty($groupTpl)) {\\n        $output[] = \'<pre>\' . print_r($groupPhs, true) . \'<\\/pre>\';\\n    } else {\\n        $output[] = $tagger->getChunk($groupTpl, $groupPhs);\\n    }\\n}\\n\\nreturn implode($groupSeparator, $output);","locked":0,"properties":"a:0:{}","moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * TaggerGetCurrentTag\\n *\\n * DESCRIPTION\\n *\\n *\\n * PROPERTIES:\\n * \\n * &tagTpl          string  optional    Name of a chunk that will be used for each Tag. If no chunk is given, array with available placeholders will be rendered\\n * &groupTpl        string  optional    Name of a chunk that will be used for each Tag. If no chunk is given, array with available placeholders will be rendered\\n * &tagSeparator    string  optional    String separator, that will be used for separating Tags\\n * &groupSeparator  string  optional    String separator, that will be used for separating Groups\\n *\\n * USAGE:\\n *\\n * [[!TaggerGetCurrentTag? &groupTpl=`currentGroup` &tagTpl=`@INLINE [[+tag]]` &tagSeparator=`, ` ]]\\n *\\n *\\n * @package tagger\\n *\\/\\n\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\'tagger\', \'Tagger\', $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\') . \'components\\/tagger\\/\') . \'model\\/tagger\\/\', $scriptProperties);\\nif (!($tagger instanceof Tagger))\\n    return \'\';\\n\\n$tagTpl = $modx->getOption(\'tagTpl\', $scriptProperties, \'\');\\n$groupTpl = $modx->getOption(\'groupTpl\', $scriptProperties, \'\');\\n$tagSeparator = $modx->getOption(\'tagSeparator\', $scriptProperties, \'\');\\n$groupSeparator = $modx->getOption(\'groupSeparator\', $scriptProperties, \'\');\\n\\n$currentTags = $tagger->getCurrentTags();\\n\\n$output = array();\\n\\nforeach ($currentTags as $currentTag) {\\n    if (!isset($currentTag[\'tags\'])) continue;\\n\\n    $tags = array();\\n    foreach ($currentTag[\'tags\'] as $tag) {\\n        $phs = array (\\n            \'tag\' => $tag[\'tag\'],\\n            \'alias\' => $tag[\'alias\'],\\n            \'group_name\' => $currentTag[\'group\'],\\n            \'group_alias\' => $currentTag[\'alias\'],\\n        );\\n\\n        if (empty($tagTpl)) {\\n            $tags[] = \'<pre>\' . print_r($phs, true) . \'<\\/pre>\';\\n        } else {\\n            $tags[] = $tagger->getChunk($tagTpl, $phs);\\n        }\\n    }\\n    \\n    $groupPhs = array(\\n        \'name\' => $currentTag[\'group\'],\\n        \'alias\' => $currentTag[\'alias\'],\\n        \'multipleTags\' => intval(count($tags) > 1),\\n        \'tags\' => implode($tagSeparator, $tags)\\n    );\\n\\n    if (empty($groupTpl)) {\\n        $output[] = \'<pre>\' . print_r($groupPhs, true) . \'<\\/pre>\';\\n    } else {\\n        $output[] = $tagger->getChunk($groupTpl, $groupPhs);\\n    }\\n}\\n\\nreturn implode($groupSeparator, $output);"}',
        'guid' => 'dd8b9dea3cc86015a7fec33866a44095',
        'native_key' => NULL,
        'signature' => 'f0d71b208e6a5f56d6ee8962fbaead5c',
      ),
    ),
    'Plugins' => 
    array (
      '4f13e49785c35ecb9d749e3838c88958' => 
      array (
        'unique_key' => 'name',
        'preserve_keys' => false,
        'update_object' => true,
        'related_objects' => 
        array (
          'PluginEvents' => 
          array (
            'ef176f6afd7265f54e506feddb0dc4f4' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnDocFormSave","priority":0,"propertyset":0}',
              'guid' => 'eda35bbfbe25aab7db58a597fa2432ab',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnDocFormSave',
              ),
              'signature' => 'c0bae3c8e8287de6a00c0b56cf38941d',
            ),
            'f53a31c50f22386bf4c09eaa0ae67376' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnDocFormPrerender","priority":0,"propertyset":0}',
              'guid' => '6553daed6f9de40acab73535bdf79178',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnDocFormPrerender',
              ),
              'signature' => 'ac7287a552c92a729cd11b930c5ed3ff',
            ),
            '0f8f7552a07cde904649b768b028ff88' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnHandleRequest","priority":0,"propertyset":0}',
              'guid' => '2203f7f59915001ea7b0412502f263dd',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnHandleRequest',
              ),
              'signature' => '270df222775f95fd43bb19aa52d3b913',
            ),
            'b56e9205326b3b293e7c9ec4071c9474' => 
            array (
              'class' => 'modPluginEvent',
              'object' => '{"pluginid":0,"event":"OnResourceDuplicate","priority":0,"propertyset":0}',
              'guid' => '1a897d628a39589e9b7817e98e2506ab',
              'native_key' => 
              array (
                0 => 0,
                1 => 'OnResourceDuplicate',
              ),
              'signature' => 'bc8a3cbc4ff8047a04626ead0fa3c392',
            ),
          ),
        ),
        'related_object_attributes' => 
        array (
          'PluginEvents' => 
          array (
            'preserve_keys' => true,
            'update_object' => false,
            'unique_key' => 
            array (
              0 => 'pluginid',
              1 => 'event',
            ),
          ),
        ),
        'class' => 'modPlugin',
        'object' => '{"id":null,"source":0,"property_preprocess":0,"name":"Tagger","description":"","editor_type":0,"category":0,"cache_type":0,"plugincode":"\\/**\\n * Tagger\\n *\\n * DESCRIPTION\\n *\\n * This plugin inject JS to add Tab with tag groups into Resource panel\\n *\\/\\n\\n$corePath = $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\', null, MODX_CORE_PATH) . \'components\\/tagger\\/\');\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\\n    \'tagger\',\\n    \'Tagger\',\\n    $corePath . \'model\\/tagger\\/\',\\n    array(\\n        \'core_path\' => $corePath\\n    )\\n);\\n\\n$className = \'Tagger\' . $modx->event->name;\\n$modx->loadClass(\'TaggerPlugin\', $tagger->getOption(\'modelPath\') . \'tagger\\/events\\/\', true, true);\\n$modx->loadClass($className, $tagger->getOption(\'modelPath\') . \'tagger\\/events\\/\', true, true);\\n\\nif (class_exists($className)) {\\n    \\/** @var TaggerPlugin $handler *\\/\\n    $handler = new $className($modx, $scriptProperties);\\n    $handler->run();\\n}\\n\\nreturn;","locked":0,"properties":"a:0:{}","disabled":0,"moduleguid":"","static":0,"static_file":"","content":"\\/**\\n * Tagger\\n *\\n * DESCRIPTION\\n *\\n * This plugin inject JS to add Tab with tag groups into Resource panel\\n *\\/\\n\\n$corePath = $modx->getOption(\'tagger.core_path\', null, $modx->getOption(\'core_path\', null, MODX_CORE_PATH) . \'components\\/tagger\\/\');\\n\\/** @var Tagger $tagger *\\/\\n$tagger = $modx->getService(\\n    \'tagger\',\\n    \'Tagger\',\\n    $corePath . \'model\\/tagger\\/\',\\n    array(\\n        \'core_path\' => $corePath\\n    )\\n);\\n\\n$className = \'Tagger\' . $modx->event->name;\\n$modx->loadClass(\'TaggerPlugin\', $tagger->getOption(\'modelPath\') . \'tagger\\/events\\/\', true, true);\\n$modx->loadClass($className, $tagger->getOption(\'modelPath\') . \'tagger\\/events\\/\', true, true);\\n\\nif (class_exists($className)) {\\n    \\/** @var TaggerPlugin $handler *\\/\\n    $handler = new $className($modx, $scriptProperties);\\n    $handler->run();\\n}\\n\\nreturn;"}',
        'guid' => '27cb6430fb1f46e79f5a25fa86c652db',
        'native_key' => NULL,
        'signature' => '4a2b1964b2f68eb7646330f300e9a71a',
      ),
    ),
  ),
  'related_object_attributes' => 
  array (
    'Children' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 
      array (
        0 => 'parent',
        1 => 'category',
      ),
    ),
    'Snippets' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Chunks' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Templates' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'templatename',
    ),
    'TemplateVars' => 
    array (
      'preserve_keys' => false,
      'update_object' => true,
      'unique_key' => 'name',
    ),
    'Plugins' => 
    array (
      'unique_key' => 'name',
      'preserve_keys' => false,
      'update_object' => true,
      'related_objects' => true,
      'related_object_attributes' => 
      array (
        'PluginEvents' => 
        array (
          'preserve_keys' => true,
          'update_object' => false,
          'unique_key' => 
          array (
            0 => 'pluginid',
            1 => 'event',
          ),
        ),
      ),
    ),
  ),
  'namespace' => 'tagger',
  'resolve' => 
  array (
    0 => 
    array (
      'type' => 'php',
      'body' => '{"source":"tagger-1.9.0-pl\\/modCategory\\/7d8f24c323a62db9e7c6754ce8863a6d.resolve.remove_tables.resolver","type":"php","name":"resolve.remove_tables"}',
    ),
    1 => 
    array (
      'type' => 'file',
      'body' => '{"source":"tagger-1.9.0-pl\\/modCategory\\/7d8f24c323a62db9e7c6754ce8863a6d\\/1\\/","target":"return MODX_ASSETS_PATH . \'components\\/\';","name":"tagger"}',
    ),
    2 => 
    array (
      'type' => 'file',
      'body' => '{"source":"tagger-1.9.0-pl\\/modCategory\\/7d8f24c323a62db9e7c6754ce8863a6d\\/2\\/","target":"return MODX_CORE_PATH . \'components\\/\';","name":"tagger"}',
    ),
    3 => 
    array (
      'type' => 'php',
      'body' => '{"source":"tagger-1.9.0-pl\\/modCategory\\/7d8f24c323a62db9e7c6754ce8863a6d.gpm.resolve.tables.resolver","type":"php","name":"gpm.resolve.tables"}',
    ),
    4 => 
    array (
      'type' => 'php',
      'body' => '{"source":"tagger-1.9.0-pl\\/modCategory\\/7d8f24c323a62db9e7c6754ce8863a6d.resolve.synctables.resolver","type":"php","name":"resolve.synctables"}',
    ),
    5 => 
    array (
      'type' => 'php',
      'body' => '{"source":"tagger-1.9.0-pl\\/modCategory\\/7d8f24c323a62db9e7c6754ce8863a6d.resolve.tables.resolver","type":"php","name":"resolve.tables"}',
    ),
    6 => 
    array (
      'type' => 'php',
      'body' => '{"source":"tagger-1.9.0-pl\\/modCategory\\/7d8f24c323a62db9e7c6754ce8863a6d.resolve.settings.resolver","type":"php","name":"resolve.settings"}',
    ),
  ),
  'validate' => NULL,
  'vehicle_package' => 'transport',
  'vehicle_class' => 'xPDOObjectVehicle',
  'guid' => '0d8c4e8dd96e7b417483a6e951391f2e',
  'package' => 'modx',
  'class' => 'modCategory',
  'signature' => '7d8f24c323a62db9e7c6754ce8863a6d',
  'native_key' => NULL,
  'object' => '{"id":null,"parent":0,"category":"Tagger","rank":0}',
);